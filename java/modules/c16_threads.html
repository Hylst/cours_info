<section id="c16">
    <div class="container">
        <div class="sec-header">
            <div class="sec-num">16</div>
            <div>
                <h2 class="sec-title">Threads & Concurrency</h2>
                <p class="sec-sub">Du Synchronized aux Virtual Threads (Loom)</p>
            </div>
        </div>

        <!-- Introduction -->
        <div class="callout callout-info">
            <h4>üéì Avant de Commencer</h4>
            <p><strong>Pr√©requis</strong> : Conna√Ætre le fonctionnement de base d'un processeur (C≈ìur/CPU).</p>
            <p><strong>Ce que vous allez apprendre</strong> : Comment faire plusieurs choses "en m√™me temps" sans que
                tout s'√©croule. La r√©volution de Java 21 (Virtual Threads).</p>
            <p><strong>Temps de lecture</strong> : ~25 minutes | <strong>Niveau</strong> : ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</p>
        </div>

        <h3 style="margin-top: 2rem; margin-bottom: 1rem;">üîÑ Concurrence vs Parall√©lisme</h3>
        <p><strong>Concurrence</strong> : G√©rer plusieurs t√¢ches qui progressent "en m√™me temps" (mais pas forc√©ment
            ex√©cut√©es au m√™me instant exact). Ex: Un serveur web g√©rant 1000 clients sur 1 CPU.</p>
        <p><strong>Parall√©lisme</strong> : Ex√©cuter r√©ellement plusieurs calculs au m√™me instant exact (sur plusieurs
            c≈ìurs).</p>

        <!-- Analogy -->
        <div class="analogy">
            <p>Le Restaurant : Serveurs vs Robots</p>
            <div class="grid2" style="margin-top:1rem; text-align:left;">
                <div>
                    <h4>üëî Platform Thread (Serveur Humain)</h4>
                    <p>Un thread classique est li√© √† l'OS. Il est lourd (2 Mo RAM), co√ªte cher √† cr√©er. Si vous avez 10
                        000 clients, vous ne pouvez pas embaucher 10 000 serveurs, sinon le restaurant explose.</p>
                </div>
                <div>
                    <h4>ü§ñ Virtual Thread (Robot Poids-Plume)</h4>
                    <p>Depuis Java 21 (Project Loom), on a des threads virtuels. Ils p√®sent quelques octets. Vous pouvez
                        en avoir <strong>des millions</strong>. Quand un robot attend (I/O), il se range et laisse la
                        place sans bloquer.</p>
                </div>
            </div>
        </div>

        <!-- Diagram -->
        <div class="diagram-container">
            <div class="mermaid">
                graph TD
                subgraph JVM [JVM / Carrier Threads]
                VT1[Virtual Thread 1] --- CT1[Carrier Thread A]
                VT2[Virtual Thread 2] --- CT1
                VT3[Virtual Thread 3] --- CT2[Carrier Thread B]
                end
                CT1 --> CPU1[CPU Core 1]
                CT2 --> CPU2[CPU Core 2]

                style VT1 fill:#3fb950,color:#f0f6fc
                style VT2 fill:#3fb950,color:#f0f6fc
                style VT3 fill:#3fb950,color:#f0f6fc
                style CT1 fill:#79c0ff,color:#f0f6fc
                style CT2 fill:#79c0ff,color:#f0f6fc
            </div>
            <p style="margin-top:10px; font-size:0.9rem; color: var(--text-muted-foreground);">M:N Mapping : La JVM
                monte et d√©monte les Virtual Threads sur les Threads OS (Carriers) dynamiquement.</p>
        </div>

        <!-- Safety Problems -->
        <h3 style="margin-top: 2.5rem; margin-bottom: 1rem;">üí• Les Dangers (Race Condition)</h3>
        <p>Si deux threads modifient la m√™me variable en m√™me temps, le r√©sultat est impr√©visible.</p>

        <div class="grid2">
            <div class="code">
                <div class="code-head"><span class="dot r"></span>Code Dangereux</div>
                <pre><span class="kw">class</span> <span class="type">Counter</span> {
    <span class="kw">int</span> <span class="var">count</span> = <span class="num">0</span>;

    <span class="com">// Non Thread-Safe !</span>
    <span class="com">// T1 lit 0, T2 lit 0</span>
    <span class="com">// T1 √©crit 1, T2 √©crit 1 -> Perte !</span>
    <span class="kw">void</span> <span class="mt">increment</span>() {
        <span class="var">count</span>++;
    }
}</pre>
            </div>
            <div class="code">
                <div class="code-head"><span class="dot g"></span>Solution 1 : Synchronized</div>
                <pre><span class="kw">class</span> <span class="type">Counter</span> {
    <span class="kw">int</span> <span class="var">count</span> = <span class="num">0</span>;

    <span class="com">// Un seul thread √† la fois !</span>
    <span class="com">// Les autres attendent (Lock)</span>
    <span class="kw">synchronized void</span> <span class="mt">increment</span>() {
        <span class="var">count</span>++;
    }
}</pre>
            </div>
        </div>

        <!-- Atomic -->
        <h3 style="margin-top: 2.5rem; margin-bottom: 1rem;">‚öõÔ∏è Solution Moderne : Atomic</h3>
        <p>Pour des op√©rations simples, n'utilisez pas <code>synchronized</code> (lent). Utilisez les classes
            <code>Atomic</code> (CAS - Compare And Swap).</p>
        <div class="code">
            <pre><span class="type">AtomicInteger</span> <span class="var">counter</span> = <span class="kw">new</span> <span class="type">AtomicInteger</span>(<span class="num">0</span>);

<span class="var">counter</span>.<span class="mt">incrementAndGet</span>(); <span class="com">// Thread-safe & Ultra rapide</span></pre>
        </div>

        <!-- Virtual Threads Example -->
        <h3 style="margin-top: 2.5rem; margin-bottom: 1rem;">üöÄ La R√©volution Java 21</h3>
        <p>Comment lancer 10 000 t√¢ches simultan√©es aujourd'hui ? Ne cr√©ez pas 10 000 threads OS !</p>

        <div class="code">
            <div class="code-head"><span class="dot b"></span>Virtual Threads & Structured Concurrency</div>
            <pre><span class="com">// Try-with-resources garantit que tout est fini √† la sortie du bloc</span>
<span class="kw">try</span> (<span class="var">var</span> <span class="var">executor</span> = <span class="type">Executors</span>.<span class="mt">newVirtualThreadPerTaskExecutor</span>()) {
    
    <span class="kw">for</span> (<span class="kw">int</span> <span class="var">i</span> = <span class="num">0</span>; <span class="var">i</span> < <span class="num">10_000</span>; <span class="var">i</span>++) {
        <span class="var">executor</span>.<span class="mt">submit</span>(() -> {
            <span class="com">// Simulation t√¢che lente (I/O)</span>
            <span class="type">Thread</span>.<span class="mt">sleep</span>(<span class="type">Duration</span>.<span class="mt">ofSeconds</span>(<span class="num">1</span>));
            <span class="kw">return</span> <span class="str">"Done"</span>;
        });
    }
} <span class="com">// Ici, Java attend que les 10 000 soient finis !</span></pre>
        </div>

        <!-- Deadlock -->
        <div class="callout callout-warning" style="margin-top: 2rem;">
            <h4>‚õî Le Cauchemar : Deadlock (Interblocage)</h4>
            <p>Quand Thread A attend une ressource que Thread B poss√®de, et Thread B attend une ressource que Thread A
                poss√®de.</p>
            <p style="margin-top:0.5rem;"><strong>Exemple</strong> :<br>
                T1 locks Resource 1, veut Resource 2.<br>
                T2 locks Resource 2, veut Resource 1.<br>
                ‚Üí <strong>Blocage infini</strong>.</p>
            <p><strong>Solution</strong> : Toujours acqu√©rir les verrous dans le <strong>m√™me ordre</strong> partout.
            </p>
        </div>

        <!-- Le Saviez-vous -->
        <div class="callout callout-recall" style="margin-top: 2rem;">
            <h4>üí° Le Saviez-vous ?</h4>
            <p><strong>Volatile</strong> : Le mot-cl√© <code>volatile</code> garantit seulement la
                <strong>visibilit√©</strong> (lecture m√©moire fra√Æche), pas l'<strong>atomicit√©</strong>.
                <code>volatile int i = 0; i++</code> n'est PAS thread-safe !</p>
            <p style="margin-top: 0.75rem;"><strong>ThreadLocal</strong> : Permet d'avoir une variable propre √† chaque
                Thread (ex: Transaction ID). Attention, avec les Virtual Threads il faut √©viter d'y stocker trop de
                donn√©es !</p>
            <p style="margin-top: 0.75rem;"><strong>ReentrantLock</strong> : Une alternative plus flexible √†
                <code>synchronized</code> qui permet des timeouts (`tryLock`).</p>
        </div>

    </div>
</section>