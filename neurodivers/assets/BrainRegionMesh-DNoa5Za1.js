import{r as s,aw as be,j as y}from"./index-lTRvPOam.js";import{b as Me,u as Pe,_ as je,D as we,V as T,c as se,P as re,d as Se}from"./ContactShadows-BJVT3-Aq.js";const C=new T,N=new T,Ee=new T,te=new Se;function We(e,t,o){const a=C.setFromMatrixPosition(e.matrixWorld);a.project(t);const i=o.width/2,r=o.height/2;return[a.x*i+i,-(a.y*r)+r]}function Re(e,t){const o=C.setFromMatrixPosition(e.matrixWorld),a=N.setFromMatrixPosition(t.matrixWorld),i=o.sub(a),r=t.getWorldDirection(Ee);return i.angleTo(r)>Math.PI/2}function Ce(e,t,o,a){const i=C.setFromMatrixPosition(e.matrixWorld),r=i.clone();r.project(t),te.set(r.x,r.y),o.setFromCamera(te,t);const c=o.intersectObjects(a,!0);if(c.length){const l=c[0].distance;return i.distanceTo(o.ray.origin)<l}return!0}function ke(e,t){if(t instanceof se)return t.zoom;if(t instanceof re){const o=C.setFromMatrixPosition(e.matrixWorld),a=N.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,r=o.distanceTo(a);return 1/(2*Math.tan(i/2)*r)}else return 1}function Oe(e,t,o){if(t instanceof re||t instanceof se){const a=C.setFromMatrixPosition(e.matrixWorld),i=N.setFromMatrixPosition(t.matrixWorld),r=a.distanceTo(i),c=(o[1]-o[0])/(t.far-t.near),l=o[1]-c*t.far;return Math.round(c*r+l)}}const A=e=>Math.abs(e)<1e-10?0:e;function ne(e,t,o=""){let a="matrix3d(";for(let i=0;i!==16;i++)a+=A(t[i]*e.elements[i])+(i!==15?",":")");return o+a}const $e=(e=>t=>ne(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Fe=(e=>(t,o)=>ne(t,e(o),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function He(e){return e&&typeof e=="object"&&"current"in e}const Te=s.forwardRef(({children:e,eps:t=.001,style:o,className:a,prepend:i,center:r,fullscreen:c,portal:l,distanceFactor:v,sprite:V=!1,transform:h=!1,occlude:u,onOcclude:B,castShadow:oe,receiveShadow:ie,material:ae,geometry:L,zIndexRange:k=[16777271,0],calculatePosition:Z=We,as:ce="div",wrapperClass:G,pointerEvents:_="auto",...g},q)=>{const{gl:J,camera:d,scene:K,size:f,raycaster:le,events:ue,viewport:de}=Me(),[m]=s.useState(()=>document.createElement(ce)),z=s.useRef(),p=s.useRef(null),Q=s.useRef(0),O=s.useRef([0,0]),W=s.useRef(null),I=s.useRef(null),S=(l==null?void 0:l.current)||ue.connected||J.domElement.parentNode,M=s.useRef(null),$=s.useRef(!1),F=s.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&He(u[0]),[u]);s.useLayoutEffect(()=>{const x=J.domElement;u&&u==="blending"?(x.style.zIndex=`${Math.floor(k[0]/2)}`,x.style.position="absolute",x.style.pointerEvents="none"):(x.style.zIndex=null,x.style.position=null,x.style.pointerEvents=null)},[u]),s.useLayoutEffect(()=>{if(p.current){const x=z.current=be(m);if(K.updateMatrixWorld(),h)m.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const n=Z(p.current,d,f);m.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${n[0]}px,${n[1]}px,0);transform-origin:0 0;`}return S&&(i?S.prepend(m):S.appendChild(m)),()=>{S&&S.removeChild(m),x.unmount()}}},[S,h]),s.useLayoutEffect(()=>{G&&(m.className=G)},[G]);const U=s.useMemo(()=>h?{position:"absolute",top:0,left:0,width:f.width,height:f.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:r?"translate3d(-50%,-50%,0)":"none",...c&&{top:-f.height/2,left:-f.width/2,width:f.width,height:f.height},...o},[o,r,c,f,h]),me=s.useMemo(()=>({position:"absolute",pointerEvents:_}),[_]);s.useLayoutEffect(()=>{if($.current=!1,h){var x;(x=z.current)==null||x.render(s.createElement("div",{ref:W,style:U},s.createElement("div",{ref:I,style:me},s.createElement("div",{ref:q,className:a,style:o,children:e}))))}else{var n;(n=z.current)==null||n.render(s.createElement("div",{ref:q,style:U,className:a,children:e}))}});const E=s.useRef(!0);Pe(x=>{if(p.current){d.updateMatrixWorld(),p.current.updateWorldMatrix(!0,!1);const n=h?O.current:Z(p.current,d,f);if(h||Math.abs(Q.current-d.zoom)>t||Math.abs(O.current[0]-n[0])>t||Math.abs(O.current[1]-n[1])>t){const P=Re(p.current,d);let b=!1;F&&(Array.isArray(u)?b=u.map(j=>j.current):u!=="blending"&&(b=[K]));const R=E.current;if(b){const j=Ce(p.current,d,le,b);E.current=j&&!P}else E.current=!P;R!==E.current&&(B?B(!E.current):m.style.display=E.current?"block":"none");const H=Math.floor(k[0]/2),he=u?F?[k[0],H]:[H-1,0]:k;if(m.style.zIndex=`${Oe(p.current,d,he)}`,h){const[j,Y]=[f.width/2,f.height/2],D=d.projectionMatrix.elements[5]*Y,{isOrthographicCamera:ee,top:fe,left:xe,bottom:pe,right:ye}=d,ve=$e(d.matrixWorldInverse),ge=ee?`scale(${D})translate(${A(-(ye+xe)/2)}px,${A((fe+pe)/2)}px)`:`translateZ(${D}px)`;let w=p.current.matrixWorld;V&&(w=d.matrixWorldInverse.clone().transpose().copyPosition(w).scale(p.current.scale),w.elements[3]=w.elements[7]=w.elements[11]=0,w.elements[15]=1),m.style.width=f.width+"px",m.style.height=f.height+"px",m.style.perspective=ee?"":`${D}px`,W.current&&I.current&&(W.current.style.transform=`${ge}${ve}translate(${j}px,${Y}px)`,I.current.style.transform=Fe(w,1/((v||10)/400)))}else{const j=v===void 0?1:ke(p.current,d)*v;m.style.transform=`translate3d(${n[0]}px,${n[1]}px,0) scale(${j})`}O.current=n,Q.current=d.zoom}}if(!F&&M.current&&!$.current)if(h){if(W.current){const n=W.current.children[0];if(n!=null&&n.clientWidth&&n!=null&&n.clientHeight){const{isOrthographicCamera:P}=d;if(P||L)g.scale&&(Array.isArray(g.scale)?g.scale instanceof T?M.current.scale.copy(g.scale.clone().divideScalar(1)):M.current.scale.set(1/g.scale[0],1/g.scale[1],1/g.scale[2]):M.current.scale.setScalar(1/g.scale));else{const b=(v||10)/400,R=n.clientWidth*b,H=n.clientHeight*b;M.current.scale.set(R,H,1)}$.current=!0}}}else{const n=m.children[0];if(n!=null&&n.clientWidth&&n!=null&&n.clientHeight){const P=1/de.factor,b=n.clientWidth*P,R=n.clientHeight*P;M.current.scale.set(b,R,1),$.current=!0}M.current.lookAt(x.camera.position)}});const X=s.useMemo(()=>({vertexShader:h?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[h]);return s.createElement("group",je({},g,{ref:p}),u&&!F&&s.createElement("mesh",{castShadow:oe,receiveShadow:ie,ref:M},L||s.createElement("planeGeometry",null),ae||s.createElement("shaderMaterial",{side:we,vertexShader:X.vertexShader,fragmentShader:X.fragmentShader})))}),ze=({region:e,isActive:t,onRegionClick:o})=>{const[a,i]=s.useState(!1);let r=[0,0,0],c,l=[1,1,1],v=[0,0,0];switch(e.id){case"frontal":r=[0,.4,.6],c=y.jsx("sphereGeometry",{args:[.6,32,16]}),l=[1.2,.8,.7],v=[.2,0,0];break;case"parietal":r=[0,.4,-.2],c=y.jsx("sphereGeometry",{args:[.55,32,16]}),l=[1.2,.7,.7];break;case"temporal":r=[.6,-.1,.1],c=y.jsx("sphereGeometry",{args:[.4,32,32]}),l=[1,.75,1.5],v=[0,.5,0];break;case"occipital":r=[0,0,-.8],c=y.jsx("sphereGeometry",{args:[.5,32,16]}),l=[1,.8,.6];break;case"cerebellum":r=[0,-.6,-.7],c=y.jsx("sphereGeometry",{args:[.4,32,16]}),l=[1.1,.5,.7];break;case"brainstem":r=[0,-1,-.4],c=y.jsx("cylinderGeometry",{args:[.2,.15,.6,16]}),v=[.3,0,0];break;case"limbic":r=[0,0,0],c=y.jsx("torusGeometry",{args:[.35,.15,16,32,Math.PI]}),v=[Math.PI/2,0,0];break;default:r=e.position||[0,0,0],c=y.jsx("sphereGeometry",{args:[.4,32,32]})}const V=()=>{o(e.id)},h=t||a?[l[0]*1.05,l[1]*1.05,l[2]*1.05]:l;return y.jsxs("mesh",{position:r,scale:h,rotation:v,onClick:V,onPointerOver:()=>i(!0),onPointerOut:()=>i(!1),children:[c,y.jsx("meshStandardMaterial",{color:e.color,transparent:!0,opacity:t||a?.9:.7,roughness:.3,metalness:.2}),(a||t)&&y.jsx(Te,{distanceFactor:10,position:[0,.8,0],className:"pointer-events-none",children:y.jsx("div",{className:"bg-background/80 backdrop-blur-sm rounded px-2 py-1 text-sm text-center shadow-md",children:e.name})})]})};export{ze as default};
